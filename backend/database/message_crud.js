// backend/database/message_crud.js
import { Pool } from "pg";
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

/** Latest message per conversation for this user (one row per thread). */
export async function getInbox(userId, { limit = 100, offset = 0 } = {}) {
  const { rows } = await pool.query(
    `
    SELECT DISTINCT ON (conversation_id)
           id, conversation_id, sent_user_id, receive_user_id, content, sent_at, status
      FROM message
     WHERE sent_user_id = $1 OR receive_user_id = $1
  ORDER BY conversation_id, sent_at DESC
     LIMIT $2 OFFSET $3
    `,
    [userId, limit, offset]
  );
  return rows;
}

/** Get *all* messages for the user (timeline, newest first). */
export async function getAllMessagesForUser(
  userId,
  { limit = 200, offset = 0 } = {}
) {
  const { rows } = await pool.query(
    `
    SELECT id, conversation_id, sent_user_id, receive_user_id, content, sent_at, status
      FROM message
     WHERE sent_user_id = $1 OR receive_user_id = $1
  ORDER BY sent_at DESC
     LIMIT $2 OFFSET $3
    `,
    [userId, limit, offset]
  );
  return rows;
}

/** Get a 1:1 conversation (oldest first) using the pair’s conversation_id. */
export async function getConversation(userA, userB) {
  const conv = [userA, userB].sort().join(":");
  const { rows } = await pool.query(
    `
    SELECT id, conversation_id, sent_user_id, receive_user_id, content, sent_at, status
      FROM message
     WHERE conversation_id = $1
  ORDER BY sent_at ASC
    `,
    [conv]
  );
  return rows;
}

/** Create a message (conversation_id is auto-generated by the table). */
export async function createMessage({
  sent_user_id,
  receive_user_id,
  content,
  status = "S",
}) {
  const { rows } = await pool.query(
    `
    INSERT INTO message (sent_user_id, receive_user_id, content, status)
    VALUES ($1, $2, $3, $4)
    RETURNING id, conversation_id, sent_user_id, receive_user_id, content, sent_at, status
    `,
    [sent_user_id, receive_user_id, content, status]
  );
  return rows[0];
}

/** Update status helpers */
export async function markDelivered(id) {
  await pool.query(`UPDATE message SET status = 'D' WHERE id = $1`, [id]);
}
export async function markReadById(id) {
  await pool.query(`UPDATE message SET status = 'R' WHERE id = $1`, [id]);
}

/** Delete a single message */
export async function deleteMessage(id) {
  await pool.query(`DELETE FROM message WHERE id = $1`, [id]);
}

/** Seed 7 fake messages between two fixed users for testing */
export async function seedSevenMessages({ me, other }) {
  const texts = [
    "hey! got a sec?",
    "yep, what's up?",
    "need help with the resume bit",
    "sure — send me the file",
    "sent! could you focus on the summary?",
    "done! check the doc now",
    "looks great — thanks!!",
  ];
  const now = Date.now();
  const inserted = [];
  for (let i = 0; i < texts.length; i++) {
    const from = i % 2 === 0 ? me : other;
    const to = i % 2 === 0 ? other : me;
    const ts = new Date(now - (texts.length - i) * 60_000);
    const { rows } = await pool.query(
      `
      INSERT INTO message (sent_user_id, receive_user_id, content, sent_at, status)
      VALUES ($1,$2,$3,$4,'S')
      RETURNING id, conversation_id, sent_user_id, receive_user_id, content, sent_at, status
      `,
      [from, to, texts[i], ts]
    );
    inserted.push(rows[0]);
  }
  return inserted;
}

/** Mark all messages from fromUser -> toUser as read */
export async function markReadByPair({ fromUser, toUser }) {
  const { rows } = await pool.query(
    `
    UPDATE message
       SET status = 'R'
     WHERE sent_user_id = $1
       AND receive_user_id = $2
       AND status <> 'R'
    RETURNING id
    `,
    [fromUser, toUser]
  );
  return rows;
}
